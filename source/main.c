#include <tonc.h>

//Collision map
#include "map1.h"

// This file is autogenerated from the file in the graphics folder
#include "back1.h"
#include "mapa1.h"
#include "sha.h"

// Define the directions animations
#define UP 0
#define LEFT 3
#define DOWN 2
#define RIGHT 1
#define IDLE 4

// Define the jump speed and gravity
#define JUMP_SPEED 8

#define GRAVITY 1

// Function prototypes
void load_back1(void);
void load_mapa1(void);
void update_sprite(void);
void update_physics(void);

// Global variables
s16 xOffset =0;
s16 yOffset =80;
u32 frame;
u8 anim;
s32 x=20;
s32 y=34;
s8 dx;
s8 dy;
bool isJumping;


OBJ_ATTR obj_buffer[128];
OBJ_AFFINE *obj_aff_buffer = (OBJ_AFFINE*)obj_buffer;

// Load the sky background into video and Map RAM
void load_back1(void){
	memcpy32(&tile_mem[1][0], back1Tiles, back1TilesLen / 4);
	memcpy32(&se_mem[31][0], back1Map, back1MapLen / 4);
}

// Load the first map into video and Map RAM and the palette
void load_mapa1(void){
	memcpy32(&tile_mem[0][0], mapa1Tiles, mapa1TilesLen / 4);
	memcpy32(&se_mem[30][0], mapa1Map, mapa1MapLen / 4);
	memcpy32(pal_bg_mem, back1Pal, back1PalLen / 4);

}

// Load the sprite into video and palette RAM
void load_sprite(void)
{
	// Load tiles and palette of sprite into video and palete RAM. Note that
	// regular memcpy() won't work. To write to VRAM, it is required to write in
	// units of 16 or 32 bytes. memcpy() doesn't guarantee the size of the
	// writes, but mempcy32() always writes in chunks of 32 bytes.
	memcpy32(&tile_mem[4][0], shaTiles, shaTilesLen / 4);
	memcpy32(pal_obj_mem, shaPal, shaPalLen / 4);

	// Initialize the sprite attribute memory
	oam_init(obj_buffer, 128);

	OBJ_ATTR *sha = &obj_buffer[0];
	// Set the first sprite (sprite 0) with the following attributes:
	obj_set_attr(sha,
		ATTR0_SQUARE,  // Square, regular sprite
		ATTR1_SIZE_32, // 32x32 pixels,
		ATTR2_PALBANK(0) | 0); // palette index 0, tile index 0

	// Set position
	obj_set_pos(sha, 40, 117);
	// Copy the OAM buffer to OAM memory
	oam_copy(oam_mem, obj_buffer, 1); // Update first OAM object
}

// Update the sprite position and animation
void update_sprite(void)
{
	OBJ_ATTR *sha = &obj_buffer[0];
	// Set the first sprite (sprite 0) with the following attributes:
	obj_set_attr(sha,
		ATTR0_SQUARE,  // Square, regular sprite
		ATTR1_SIZE_32, // 32x32 pixels,
		ATTR2_PALBANK(0) | 
		// Calculate the tile index based on the animation frame
		((anim*48)+(frame%3)*16)); // palette index 0, tile index (calculated)
	// Set position
	obj_set_pos(sha, x, y);
	// Copy the OAM buffer to OAM memory
	oam_copy(oam_mem, obj_buffer, 1);
}

// Update the physics of the player
void update_physics(void){
	// Read the keys for direction
	dx=key_tri_horz();
	// If the A key is pressed and the player is not jumping, then jump
	if(key_hit(KEY_A)){
		if(!isJumping){
			isJumping=true;
			dy=-JUMP_SPEED;
		}
	}
	// If the player is jumping, then apply gravity
	y+=dy;
	dy+=GRAVITY;
	
	
	s8 dtile=0;
	
	// Get current tile position
	s16 tile_x=((x+xOffset)/8);
	s16 tile_y=((y+yOffset)/8);

	// Check the collision with the map
	if(collision_map1[(tile_y+4)*32+tile_x]!=1){
		isJumping=false;
		dy=0;
	}
	
	//Check animation and offset for right
	if(dx>0){
		anim=RIGHT;
		if(x>140){
			dx=0;
			xOffset++;
		}
		//check animation and offset for left
	}else if(dx<0){
		anim=LEFT;
		if(x<20){
			dx=0;
			xOffset--;
		}
	}else{
		//idle animation
		anim=IDLE;
	}

	if(anim==RIGHT){
		dtile=3;
	}

	// Check the collision with the map for x axis
	if(collision_map1[(tile_y+1)*32+(tile_x+dtile)]!=1){
		dx=0;
	}
	// Update the x position
	x+=dx;
}

int main(void)
{
	// Initialize the interrupt handler
	irq_init(NULL);
	irq_enable(II_VBLANK);
	// Initialize the global variables
	anim=IDLE;
	frame=0;
	dx=0;
	dy=0;
	isJumping=false;
	// Load the background and the map
	load_back1();
	load_mapa1();
	//initialize Backgrounds using Background registers.
	REG_BG1CNT = BG_CBB(1) | BG_SBB(31) | BG_8BPP | BG_REG_32x32;
	REG_BG0CNT = BG_CBB(0) | BG_SBB(30) | BG_8BPP | BG_REG_32x32;
	// Load the sprite
	load_sprite();
	//initialize display control register
	REG_DISPCNT = DCNT_MODE0 | DCNT_BG0 | DCNT_BG1| DCNT_OBJ | DCNT_OBJ_1D;
	
	while (1) {
		// Wait for VBlank
		VBlankIntrWait();
		// Poll the keys
		key_poll();
		// Update the physics and the sprite
		update_physics();
		// Update the Scroll offset for BG0
		REG_BG0HOFS = xOffset;
		REG_BG0VOFS = yOffset;
		// Update the sprite
		update_sprite();
		// Update the frame
		frame++; 
	}
}
